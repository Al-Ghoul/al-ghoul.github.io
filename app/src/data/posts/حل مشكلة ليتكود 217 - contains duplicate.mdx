---
title: حل مشكلة ليتكود 217 - contains duplicate
author: abdulrahman-alghoul
publishedAt: 2025-11-02
# updatedAt:
description: ""
coverImage: ""
lang: ar
category: شروحات
tags: 
- leetcode
- neetcode
- شروحات
- عربي
series: "neet-code-150"
seriesIndex: 1
relatedPosts: []
draft: false
---
#  مقدمة
في هذا المقال سنتطرق إلي حل المشكلة رقم 217 [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/) علي لييت كود أو LeetCode.
# فهم المشكلة
قبل الشروع في حل المشكلة، علينا أن نفهم ماهية المشكلة المطروحة و من ثم المطلوب حله و ما الذي قد يساعدنا من هياكل بيانات في ترسانتنا البرمجية. أحد العواقب الأولية و هي عدم فهم المشكلة و متطلباتها بشكلٍ صحيح، يظل المبرمج يخمن بخوارزميات عشوائية مع تعديلات تكرارية إلي أن تُحل المشكلة، و هذا قد يعمل بعض الأحيان و لكن يضيع الكثير من الوقت الثمين.

وصف المشكلة المطروح هو الآتي:
<p dir="ltr">Given an integer array `nums`, return `true` if any value appears **at least twice** in the array, and return `false` if every element is distinct.</p>

مما يعني أن المشكلة عبارة عن مجموعة من الأرقام تسمي `nums`، المطلوب هو أن نرجع بـ`حق` أو `true` إن وجدنا أي قيمة مكررة علي الأقل مرتين و بـ`باطل` أو `false` إن لم نجد أي تكرار.

## الشروع في الحل

### حل النهج الغشيم 
سنبدأ بالحل السهل و البديهي و هو حل *النهج الغشيم*[^1]:

```ts
function containsDuplicate(nums: number[]): boolean {
	const n = nums.length;                            // حجم المجموعة
	for (let idx = 0; idx < n; idx += 1) {           // nums نمط تكراري لمعالجة جميع العناصر في 
		for (let j = idx + 1; j < n; j += 1) {      // كمؤشر j باستخدام idx لكل عنصر يتم معالجته خلال idx نمط تكراري لمعالجة العناصر التي تأتي بعد 
			if (nums[idx] == nums[j]) return true; // التحقق من التكرار
		}
	}
	return false; // لم نجد أي تكرار
}
```

لنشرح ما الذي تفعله هذه الخوارزمية بالتحديد، سطراً بسطر:
1. السطر الأول هو مجرد تعيين لحجم المجموعة `nums` و يتم تخزينه بالمتغير `n`
2. السطر الثاني يُنشئ نمط تكراري من بداية المجموعة (الفهرس `صفر`) إلي نهايتها (الفهرس `n - 1`) باستخدام المؤشر `idx` و الذي يقوم بزيارة كل عنصر بالمجموعة وفقاً لذلك
3. السطر الثالث و الذي يُنشئ نمط تكراري آخر *داخلي* من `idx + 1` إلي نهاية المجموعة (الفهرس `n - 1`) باستخدام المؤشر `j` و الذي يقوم بزيارة كل عنصر بالمجموعة وفقاً لذلك

في كل مرة يتم فيها زيارة عنصريين خلال المؤشرين `idx` و `j` يتم المقارنة بينهم و إن كانوا متساويين فترجع الخوارزمية بقيمة `حق` أو `true` و علي العكس إن تم زيارة جميع العناصر و لم تجد الخوارزمية أي تكرار بين العناصر فترجع الخوارزمية بقيمة `باطل` أو `false`.

مثال علي مجموعة لا تحتوي علي تكرار:

<iframe
    src="/neet_code_150/contains_duplicates/brute_force_has_no_duplicates/slides.html"
    width="100%"
    height="600"
    style="border: 1px solid #e17100"
    allowfullscreen
  ></iframe>

مثال علي مجموعة تحتوي علي تكرار:

<iframe
    src="/neet_code_150/contains_duplicates/brute_force_has_duplicates/slides.html"
    width="100%"
    height="600"
    style="border: 1px solid #e17100"
    allowfullscreen
  ></iframe>

علي أن أوضح شيئاً قبل المضي قدُماً إلي الخوارزمية الأكثر فعالية، لكل عنصر يتم زيارته خلال المؤشر `idx` يتم زيارة كل ما بعده من عناصر خلال المؤشر `j`، إن قُلنا أن حجم المدخل `nums` هو `n` فذلك يعني أنه يتم زيارة العناصر $n * n$ أو <span dir="ltr">($n^2$)</span> عنصراً، و بالتالي يتم زيارة كل عنصر بالمجموعة ما يعني أننا نكرر أنفسنا (و هنا يكمن عُنق الزجاجة للخوارزمية).

فالـBig O لهذه الخوارزمية هو الآتي:
 - للتشغيل <span dir="ltr">($n^2$)O</span>
 - للتخزين <span dir="ltr">($1$)O</span>  (لم نخزن شئ إلا حجم المجموعة و الذي هو رقم ثابت نسبياً أو بعبارة أخري هو سيستحوذ علي نفس المساحة من الذاكرة مهما اختلف الرقم نفسه)
### الحل الأكثر كفائة

الآن و بشرح الحل البدائي، فلنتطرق إلي الحل الأكثر كفائة، لنبدأ بسؤال أنفسنا بضعة أسئلة:
1. أين يكمن البطء في خوارزميتنا السابقة؟
2. هل يوجد شئ في ترسانتنا من هياكل بيانات يمكنه المساعدة في تسريع الخوارزمية؟

إجابة السؤال الأول:  إن أمعنت في التفكير فستجد أنه كما أشرتُ مسبقاً في كل مرة يتقدم فيها المؤشر `idx` ليشير إلي عنصر جديد، يعيد `j` النظر خلال العناصر الأخري التي تأتي بعد `idx` و يبدأ `j` بتكرار نفسه بسرعة أي أنه عندما يشير `idx` للعنصر الثاني (أي أن`idx = 1`) فيكون `j` يكرر نفسه بالفعل و لكن المختلف فقط هو أن `idx` يشير إلي عنصر جديد (و كذلك `j` لأنه يشير إلي ما بعد `idx` و لكن `j` يشير لهم مرة أخري كلما تقدم و من هنا يأتي التكرار).

إجابة السؤال الثاني: بالإجابة علي السؤال الأول يكون قد جائنا حدس أو إشارة لتسريع هذه الخوارزمية أي أن إن كان بإمكاننا تذكر الأرقام التي حللناها سابقاً و تفقد إن كان الرقم الجديد الذي يتم معالجته يكمن في تلك الأرقام؟
الإجابة هي نعم فيوجد طريقتان أي أنه لدينا هيكلين من البيانات يدعم التفقد السريع للعناصر من غير استخدام أي خوارزميات تكرارية، أي أن تفقد إن كان بهم عنصر هو O(1) للتشغيل

السؤال هو، ما هم الهيكلين؟
1. Sets (مجموعة لا تقبل التكرار)
2. Maps (قاموس يقوم بربط مفتاح بقيمة مختارة مقابلة)
و جافاسكريبت بها الهيكلين و لكن شرح الهيكلين و كيفية التعامل معهما خارج نطاق هذا المقال، الخوارزميات كالآتي:
```ts
function containsDuplicate(nums: number[]): boolean {
    const numsSet = new Set();                // إنشاء مجموعة (لا تقبل التكرار)
    for (const num of nums) {                // nums نمط تكراري لمعالجة جميع العناصر في
        if (numsSet.has(num)) return true;  // إن كان بها الرقم الذي يتم معالجته حالياً numsSet التحقق من التكرار من خلال فحص 
        numsSet.add(num);                  // حفظ العنصر الذي تمت رؤيته و معالجته
    }
    return false; // لم نجد أي تكرار
}
```

```ts
function containsDuplicate(nums: number[]): boolean {
    const numsMap = new Map();               // إنشاء قاموس أو خارطة
    for (const num of nums) {               // nums نمط تكراري لمعالجة جميع العناصر في
        if (numsMap.has(num)) return true; // إن كان بها الرقم الذي يتم معالجته حالياً numsMap التحقق من التكرار من خلال فحص 
        numsMap.set(num, 0);              // حفظ العنصر الذي تمت رؤيته و معالجته
    }
    return false; // لم نجد أي تكرار
}
```

الخوارزميتين متشابهتين و الفرق فقط في استخدام هيكل مختلف لذا لنشرح ما الذي تفعله إحداهما و نري ما المقايضات التي نتُجت عن ذلك، سطراً بسطر:
1. السطر الأول ينشئ هيكل و يجهزه للإستخدام
2. السطر الثاني هو نمط تكراري لمعالجة جميع العناصر الموجودة بالمجموعة `nums`
3. السطر الثالث يفحص إن كان العنصر الذي يتم معالجته حالياً موجود في هيكل البيانات المُستخدم
4. السطر الرابع يخزن العنصر الذي قمنا بمعالجته أي نتذكر أنه موجود

مثال علي مجموعة لا تحتوي علي تكرار:

<iframe
    src="/neet_code_150/contains_duplicates/efficient_algorithm_has_no_duplicates/slides.html"
    width="100%"
    height="600"
    style="border: 1px solid #e17100"
    allowfullscreen
  ></iframe>

مثال علي مجموعة تحتوي علي تكرار:

<iframe
    src="/neet_code_150/contains_duplicates/efficient_algorithm_has_duplicates/slides.html"
    width="100%"
    height="600"
    style="border: 1px solid #e17100"
    allowfullscreen
  ></iframe>

و الآن ما هي المقايضات التي نتُجت هنا؟ (عادتاً ما يكون هناك مقايضات إما لتسريع الخوارزمية و ذلك باستخدام هيكل بيانات معين أو باستخدام ذاكرة أقل و بذلك معالجة أكثر و كود أكثر أو أداء أقل) إن تمعنا بالتفكير و بمعرفة أننا نستخدم ذاكرة أكثر و هذا ما سمح لنا بإزالة النمط التكراري الثاني المتداخل مما أتاح لنا أيضاً أن نعالج تلك العناصر خلال نمط تكراري واحد و بهذا صارت الخوارزمية بسرعة تشغيل O(n) و لكن ما مدي الذاكرة الذي تستخدمه هذه الخوارزمية في أسوأ سيناريو؟ إن تمعنا بالتفكير فيمكن أن يكون التكرار بالوسط أو بآخر المجموعة و ألا يكون هناك تكرار نهائياً مما يعني أنه بالمتوسط سنخزن حوالي $n/2$ عنصر من المجموعة الأصلية في الهيكل المستخدم في كلتا الخوارزميتين و لكن طبقاً لقواعد Big O فنحن مهتمون فقط بأسوأ سيناريو و الذي هو سيتم تخزين `n` عدد من العناصر.

فالـBig O لهذه الخوارزمية هو الآتي:
 - للتشغيل <span dir="ltr">($n$)O</span>
 - للتخزين <span dir="ltr">($n$)O</span>

___ 
[^1]: **النهج الغشيم**: في سياق الخوارزميات يرمز تصنيف النهج الغشيم إلي خوارزميات تُجرٍب جميع الإحتمالات الممكنة، مما يعني عمل زائد في أغلب الأحيان و بلا منفعة و بذلك أداء بطئ و متدهور كلما زاد حجم أو قيمة المدخلـ(ـات).
